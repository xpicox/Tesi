%!TEX root = thesis.tex

\chapter{Analysis}

The first implementation, proposed by \citet{Toneguzzo}, made a heavy use of Haskell STM: all the operations performed on shared data structures were executed by STM transactions. Since this work aims to be an alternative to STM, we decided to set up a new implementation that does not have the STM as a dependency. This led us to thoroughly study STM and the GHC internals.


\section{The Glasgow Haskell Compiler}
Although there are several Haskell compilers, the Glasgow Haskell Compiler (GHC) is the reference compiler of Haskell. GHC was started as part of an academic research project with several goals in mind, one of which was to provide a modular foundation that researchers can extend and develop.

At the highest level GHC can be divided into two parts:
\begin{itemize}
 \item The compiler itself. This is an Haskell program whose job is to convert Haskell source code into executable machine code.
 \item The Runtime System (RTS). This is a large library of C code that handles all the tasks associated with running the compiled Haskell code, including garbage collection, thread scheduling, profiling, exception handling. The RTS is linked into every compiled Haskell program.
 \end{itemize}
The compilation route of a source file involves several phases, with the output of each phase becoming the input of the subsequent phase. What distinguishes GHC from other compilers, and is worth mentioning, is that the source code is translated into several intermediate languages: in a first phase the source code is parsed and type-checked, then all the syntactic sugar, \ie syntactic constructs that can be translated into simpler constructs, is removed, translating Haskell syntax into a much smaller language called \emph{Core}. The next phase is the optimization one: there are about six passes of optimization each of which takes \emph{Core} and produces \emph{Core}; in this phase, optimizations like dead code elimination, constants propagation or function inlining are applied to the program. Once the \emph{Core} program has been optimized, the process of code generation begins. The code generator first converts the \emph{Core} into a language called \emph{STG}, which is essentially just \emph{Core} annotated with more information required by the code generator. Then, \emph{STG} is translated to \emph{Cmm}, a low-level imperative language with an explicit stack. Finally, the \emph{Cmm} is converted to LLVM code (IR) and passed to the LLVM compiler that produces the native code.

\section{Spineless Tagless G-Machine}

The Spineless Tagless G-Machine (STGM) is an abstract machine designed to support non-strict higher-order functional languages; this abstract machine defines a precise evaluation model for Haskell code and lays down the layout of Haskell objects involved in the evaluation process. \cite{export:67083}

The Runtime System implements the mapping of the STG language onto an architecture with registers and explicit stack management. It provides the support infrastructure needed for running compiled Haskell code, including a storage manager, responsible for the allocation and the garbage collection, and a scheduler.

The STG-Machine adopts a uniform representation for all heap-allocated objects (whether values or thunks, \ie unevaluated object) and in the Runtime System they are referred to as \emph{Closures}.

Every \emph{Closure} is a contiguous block of memory, consisting of a fixed-format \emph{header} and a \emph{payload} with variable size.
The most important part of the header is the \emph{info pointer},  which points to the info table for the closure.

The \emph{info table} contains all the information that the runtime needs to know about the closure.
Info tables are contiguous blocks of memory that, in addition to provide informations for the storage manager, contain the type of the closure and the \emph{entry code}, \ie the machine code that will evaluate the closure.
\textbf{Aggiungere schema Closure + Info Table. Vedi GHC Commentary:} \url{https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#InfoTables}

Heap objects can be classified in:
\begin{itemize}
\item \emph{executive objects} that participate directly in the execution of a program, \eg thunks, functions, data constructors. They can be subdivided into two kinds of objects based on their type:
\begin{itemize}
\item \emph{Boxed} types are represented by a pointer to an object in the heap;
\item \emph{Unboxed} types are represented by their value, not a pointer.
\end{itemize}
\item \emph{administrative objects} that do not represent values in the original program.
\end{itemize}

The \emph{executive objects} are the citizens of an Haskell program. Among \emph{executive objects} there are:
%& \emph{closures} representing data constructors, \emph{closures} representing thunks generated by let expressions or case expressions, \emph{closures}
\begin{itemize}
\item Constructors: used to represent data constructors. Their payload consists of the fields of the constructor.
\item Primitive objects: used to represent mutable objects such as mutable arrays, mutable variables, MVars and TVars. Their payload varies according to the kind of object.
\item Function closures: used to represent functions. Their payload (if any) consists of the free variables of the function.
\item Thunks: used to represent unevaluated expressions which will be updated with their result. The entry code for a thunk starts by pushing an \emph{update frame} onto the stack. When evaluation of the thunk completes, the update frame will cause the thunk to be overwritten again with an \emph{indirection} to the result of the thunk.
\item Partial applications: used to represent the application of a function to an insufficient number of arguments. Their payload consists of the function and the arguments received so far.
\end{itemize}
\newpage
Cose ancora da dire:

Threads, Capabilities..:
[ one OSThread per Capability although during the course of running the program more OS threads might be created in order to continue running Haskell code while foreign calls execute. ]
\url{https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler}

E infine dove st√† STM?
\url{https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/STM}